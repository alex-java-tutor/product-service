server:
  port: 8081
  # говорим серверу, чтобы при получении сигнала SIGTERM он более не принимал
  # новые запросы, но при этом выполнил те, что уже в работе в течение времени,
  # которое указано в настройке spring.lifecycle.timeout-per-shutdown-phase
  # по умолчанию 30 секунд
  # подробнее тут: https://habr.com/en/companies/maxilect/articles/666090/
  shutdown: graceful
  tomcat:
    # говорим Tomcat сколько времени ждать после открытия соединения до получения запроса.
    # Может быть полезно для защиты от DoS атак, когда клиент устанавливает соединение,
    # сервер выделяет поток для его обработки, но запрос не приходит.
    # Это же время Tomcat будет тратить на чтение тела запроса.
    connection-timeout: 3s
    # время, в течение которого Tomcat удерживает соединение открытым, ожидая новых запросов
    keep-alive-timeout: 20s
    # Tomcat использует пул потоков для обработки входящих соединений: одно соединение - один поток.
    # По умолчанию макимальное количество потоков в пуле - 200.
    threads:
      max: 200
      # минимальное количество потоков, которые будут созданы в пуле при старте сервера
      min-spare: 10
spring:
  application:
    name: product-service
  lifecycle:
    timeout-per-shutdown-phase: 30s # время, в течение которого текущие запросы будут отрабатываться после получения сигнала SIGTERM
  datasource:
    username: user
    password: password
    url: jdbc:postgresql://localhost:5432/product_service_db
    hikari:
      # таймаут на получение соединения из пула соединений
      connection-timeout: 2000 # в миллисекундах
      # по умолчанию в приложении используется пул соединений с БД HikariCP.
      # его размер конфигурируется этой настройкой. Специалисты команды HikariCP рекомендуют
      # устанавливать количество соединений, исходя из формулы:
      # connections = ((core_count * 2) + effective_spindle_count)
      # где core_count - количество ядер процессора
      # effective_spindle_count - количество вращающихся дисков
      # Так как мы предполагаем, что будет использоваться SSD, вращающихся дисков не будет,
      # поэтому effective_spindle_count = 0
      # Мы также предполагаем, что количество ядер = 6, следовательно maximum-pool-size = 12
      # более подробно тут: https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
      maximum-pool-size: 12
  jpa:
    hibernate:
      # говорим hibernate, что необходимо провалидировать соответствие схемы БД и JPA модели
      ddl-auto: validate
    properties:
      hibernate:
        # говорим hibernate, чтобы выводимые в логи sql запросы были отфрматированы для удобства чтения
        format_sql: true
        # говорим hibernate показывать sql запросы в логах (для отладки и тестирования)
        show_sql: true
  config:
    # параметр, определяющий место хранения дополнительных конфигураций приложения.
    # При указании “configserver:” приложение будет пытаться связаться с конфигурационным
    # сервером, адрес которого можно указать в этом же параметре, либо в
    # spring.cloud.config.uri. Мы воспользуемся первым вариантом. Однако при такой
    # конфигурации, если будет ошибка связи с сервером, приложение упадет. Чтобы избежать
    # этого, можно добавить префикс optional -  “optional:configserver”. В этом случае
    # приложение не упадет, но в логах будет предупреждение, а конфигурации будут
    # использованы те, которые прописаны локально в application.yml. В проде использование
    # префикса optional не рекомендуется.
    # мы ссылаемся на кастомный параметр configserver.import, однако чтобы это сработало,
    # нам дополнительно необходимо добавить spring.cloud.config.import-check.enabled = false,
    # в противном случае ${configserver.import} будет рассматриваться как обычная строка,
    # а не ссылка на параметр
    import: ${configserver.import}
  cloud:
    config:
      import-check:
        enabled: false
      # таймаут на соединение с сервером конфигурации в миллисекундах.
      request-connect-timeout: 5000
      # таймаут на получение данных с сервера в миллисекундах
      request-read-timeout: 5000
      # параметр, говорящий микросервису необходимо ли ошибки связи с конфигурационным
      # сервером рассматривать как критические. В проде этот параметр рекомендуется
      # выставлять как true
      fail-fast: false
      retry:
        max-attempts: 6
        initial-interval: 1000
        max-interval: 2000
        multiplier: 1.1
      label: master

configserver:
  import: optional:configserver:${CONFIG_SERVER_URL:http://localhost:8085}

springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html

api:
  product-create:
    summary: Создание товара
    description: |
      Создает товар и сохраняет его в базе данных.
      Возвращает информацию о созданном товаре, включая его идентификатор.
  product-delete:
    summary: Удаление товара.
    description: Удаляет товар по идентификатору.
  product-update:
    summary: Обновление товара.
    description: Обновляет товар в соответствии с переданными в теле запроса параметрами.
  product-get:
    summary: Получение товара.
    description: Возвращает информацию о товаре по его идентификатору.
  product-list-get:
    summary: Получение списка товаров.
    description: |
      Возвращает список товаров.
      Список отсортирован в соответствии с указанным параметром сортировки.
      Доступные параметры сортировки: 
      az - сортирует по названию в алфавитном порядке
      za - сортирует по названию в обратном порядке
      price_asc - сортирует по возрастанию цены
      price_desc - сортирует по убыванию цены
      date_asc - сортирует по дате создания меню в порядке возрастания
      date_desc - сортирует по дате создания меню в порядке убывания
      Список пагинирован в соответствии с переданными параметрами from и size.
  product-info:
    summary: Получение информации о цене и доступности товаров.
    description: |
      Возвращает информацию о цене, названии и доступности товара. Если товара нет в базе,
      его цена представлена null значением. Несмотря на то, что семантика запроса полностью
      соответствует HTTP GET запросу, используется именно POST, так как в теле запроса может
      быть передан длинный список названий товаров.
  response:
    createOk: Товар создан успешно
    createConflict: Товар не был создан, так как товар с таким названием уже существует в базе.
    createBadRequest: Товар не был создан, так как запрос содержит ошибки. Подробнее в сообщении об ошибке.
    deleteNoContent: Товар с идентификатором более не хранится в базе данных.
    updateOk: Товар успешно обновлен.
    notFound: Товар с таким идентификатором не найден в базе данных.
    updateBadRequest: Товар не был обновлен, так как запрос содержит ошибки. Подробнее в сообщении об ошибке.
    getOk: Товар успешно найден.
    getListOk: Список товаров успешно сформирован.
    getListBadRequest: Список товаров невозможно сформировать, так как в запросе некорректные параметры.
    getProductInfoBadRequest: Информацию о товарах невозможно сформировать, так как в запросе некорректные параметры (список названий пуст).
    getProductInfoOk: Информация о товарах успешно сформирована.
